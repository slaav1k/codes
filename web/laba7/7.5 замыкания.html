<!doctype html>
<html>
<head>
<meta charset="utf-8"> 
<script>

	// функции в Javascript могут быть вложенными
	function hypotenuse(a, b)
	{
		function square(x) { return x * x; }
		return Math.sqrt(square(a) + square(b));
	}
	console.log(hypotenuse(5,10)); // 11.18
	
	// вложенные функции обладают доступом ко всей цепочке видимости точки определения
	var x = 5;
	function outFunc(y, z)
	{
		function inFunc(a) 
		{ 
			console.log(x, y, z, a); 
		}
		
		inFunc(20);
	}
	outFunc(10,15); // 5, 10, 15, 20
	
	// функции в языке Javascript являются полноценными объектами 
	// (т.е. значениями или данными) поэтому иметь несколько ссылок
	// на одну и туже функцию
	function double(x) { return x * 2; }
	var d = double;
	
	// теперь у нас две ссылки на одну и ту же функцию
	console.log(double(5)); // 10
	console.log(d(5)); 		// 10
	
	// функцию как значение можно присвоить любой переменной, даже
	// элементам массива. Для вызова объекта функции нужно использовать ()
	var a = [x => x * x, 10];
	console.log(a[0](a[1])); // 100
	
	
	// функцию сохраняют связь с локальными переменными и параметрами внешней функции, 
	// где они были определены (а не вызваны!)
	var scope = "global";
	function checkScope()
	{
		var scope = "local";
		
		function f() { return scope; }
		
		return f;
	}
	
	var f = checkScope(); // checkScope возвращает объект функции!
	console.log(f()); // "local"
	//в более кратком варианте:
	console.log(checkScope()());  // "local"
	
	// эта особенность является самой удивительной и мощной чертой замыканий.
	// мы можем переписать ранее описываемую функцию uniqueID след. образом:
	
	var uniqueID = (function()
	{
		var counter = 0;
		return () => counter++;
	}());
	console.log(uniqueID()); // 0
	console.log(uniqueID()); // 1
	console.log(uniqueID()); // 2
	
	/*
	На первый взгляд, это выглядит как инструкция присваивания функции переменной uniqueID. 
	Фактически же это определение и вызов(!) функции, поэтому в действительности переменной 
	uniqueID присваивается значение, возвращаемое анонимной функцией. 
	Если обратить внимание на тело функции, можно увидеть, что она возвращает другую функцию. 
	Именно этот объект вложенной функции и присваивается переменной uniqueID.
	
	После возврата из внешней функции никакой другой программный код не будет иметь доступа 
	к переменной counter: вложенная функция будет обладать исключительным правом доступа к ней.
	*/
	
	// В одной и той же внешней функции вполне возможно определить две или более 
	// вложенных функций, которые будут совместно использовать одну цепочку областей видимости:

	function counter()
	{
		var n = 0;
		
		return  {
					count: () => n++,
					reset: () => n = 0
				}
	}
	
	var c = counter(), d = counter(); // создаём два независимых счётчика
	
	console.log(c.count()); // 0
	console.log(d.count()); // 0 (действуют независимо! Т.к. при каждом вызове counter создаётся новая n!)
	console.log(c.count()); // 1
	console.log(d.count()); // 1
	console.log(c.reset()); // 0 (reset и count используют совместно одну переменную n в замыкании)
	console.log(d.count()); // 2 reset от 'с' не оказывает влияние на 'd'
	
	
	/*
		Может показаться, что локальные переменные, объявленные во внешней функции, прекращают свое существование 
		после выхода из нее. Тогда как вложенная функция может использовать цепочку областей видимости, которая 
		больше не существует?
		
		В языке JavaScript каждая область видимости описывается как список объектов, а не размещается на стеке 
		(как в С\С++). Каждый раз, когда интерпретатор вызывает функцию, он создает новый объект для хранения 
		локальных переменных этой функции, и этот объект добавляется в цепочку областей видимости. 
		
		Когда функция завершается, этот объект удаляется из цепочки и, при отсутствии других ссылок, удаляется 
		сборщиком мусора. Все вложенные функции по сути также являются локальными переменными, и, хоть и владеют 
		ссылкой на ту же цепочку областей видимости, также будут удалены сборщиком мусора, когда выйдут за 
		область своего определения.
		
		Но если внешняя функция определяет вложенную функцию и возвращает ее или сохраняет в свойстве какого-либо 
		объекта как значение, то образуется внешняя ссылка на вложенную функцию и такой объект не будет удалён 
		сборщиком мусора, а следовательно не будет удалена и вся цепочка областей видимости с локальными переменными, 
		на которые ссылается вложенная функция.

	*/
	
</script>
</head>
<body>
</body>
</html>

